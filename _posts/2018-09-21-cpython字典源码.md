---
layout: post
title:  cpython字典源码
date: 2018-09-21 20:36:37 +0800
comments: false
---


本文源代码基于 commit: 73820a60cc3c990abb351540ca27bf7689bce8ac


### 哈希表：开放定址法
As we all know，在需要快速搜索的场景下，哈希表提供O(1)的检索复杂度。哈希就可能会产生冲突。对冲突的处理基本上分为两大类：链表法（又称拉链法），开放定址检测法。
链表法，就是说在每个哈希槽(slot)上其实都是一个链表表头，所有落入这个槽的元素都接入这个链表。

开放定址检测法，本质就是`多试几次，万一可以呢`，发现本key的哈希槽被占用的时候，使用一个算法算一算下一个槽的位置，可以就占掉，不可以就再试下去。

个人觉得，这两种方法在实现和使用的时候，各有不同。链表法实现较为直观，但可能造成空间浪费。想象申请了n块内存，结果哈希值比较稀疏，值都落到了几个大链表里，就不划算。另一方面，链表法什么时机重hash也是一个问题（个人感觉），毕竟单个槽过长，搜索会退化成O(n)。开放定址检测不存在内存浪费，申请多少用多少，在扩容之前只会用这些申请的内容。重hash的时机也比较好掌握；但是在设计`检测算法`的时候也要注意，首要是不能产生死循环（在有空位的情况下，要能最终找到至少一个空位），其次二次检索的效率也要注意。比如线性检测就不太好，在哈希槽较满的情况下容易产生近O(n)的效率。

cpython中解决字典的哈希冲突使用的是开放定址法。

### 开放定址法的删除
链表法中要删除一个元素很容易，把他从哈希槽的链表里拿掉就好了。但开放定址法不能简单地删掉。举个例子，用`线性探测`(虽然不好)时，搜索其实构成了一个搜索顺序。比如搜索`key为13, hash值为3`（比如hash函数就是n%10）的元素能插入哪个位置，3，4，5都已经有元素了，那么搜索顺序会有
```
    3(have) --> 4(have) --> 5(have) --> 6(null)
```
ok, 找到了我的家（yeah），那么`key 13`就落户编号6的哈希槽。但是这个时候，用户删除了位置`4`的哈希槽元素，然后再去搜索`key 13`元素位置的时候会变成这样:
```
    3(have) --> 4(null) --> 5(have) --> 6(have 13)
```
到位置4的时候发现没有了。可能有人会问，那算法继续搜索下去就好了嘛，总会找到`key 13`的，但这是在知道这个key存在的情况下才有意义；如果算法这么实现的话，所有搜索不存在key的情形都会把搜索算法变成O(n)，`因此开放定址法的搜索止于找到该key或发现一个空位`。如上，这个搜索空间就断裂了。（这个问题在cpython源码注释中也有说明）

所以开放定址法不能直接删除元素，而是应该标记删除，以确保搜索空间的完整连续性，构造出如下的搜索空间：
```
    3(have) --> 4(dummy) --> 5(have) --> 6(have 13)
```

其中，`dummy`就是cpython中使用的标记删除，算法跑到4处会继续向下搜索直到6的位置


### cpython的搜索
上代码
```c
static Py_ssize_t _Py_HOT_FUNCTION
lookdict(PyDictObject *mp, PyObject *key,
         Py_hash_t hash, PyObject **value_addr)
```
cpython中关于在dict中搜索的代码位于`dictobject.c`，函数签名如上。参数中传入一个操作的字典对象mp，查找的key，该key的hash值(传入是因为之前算过，就不要重复算了)，最后一个参数是查找出来的值的引用，需要在函数内赋值（或者没找到置空）。返回值就是该key的位置，有三种可能：
- `DKIX_EMPTY`
- `DKIX_DUMMY`
- 某个大于0的数字。

`DKIX_EMPTY`就是说没找到，`DKIX_DUMMY`就是说找到了这个key的位置，但是已经被删除了，最后就是找到的哈希槽编号的数值了。